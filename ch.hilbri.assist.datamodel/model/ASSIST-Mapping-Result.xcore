@GenModel(copyrightText="Copyright 2014 - Robert Hilbrich")

package ch.hilbri.assist.result.mapping

import ch.hilbri.assist.model.DesignAssuranceLevelType
import ch.hilbri.assist.model.HardwareArchitectureLevelType
import ch.hilbri.assist.model.IOAdapterProtectionLevelType
import ch.hilbri.assist.model.IOAdapterType
import java.util.HashMap
import org.eclipse.emf.common.util.BasicEList



interface Comparable wraps Comparable<Result>{}


class Result extends Comparable {
	
	@GenModel(documentation="Name of this result") 
	String							name
	
	@GenModel(documentation="Name of the system")
	String							systemName
	
	@GenModel(documentation="List of all hardware elements in the top hierarchy level")
	contains HardwareElement[0..*]	rootHardwareElements
	
	@GenModel(documentation="Returns the top hardware level for this result")
	derived HardwareArchitectureLevelType topHardwareLevel get {
		if (!rootHardwareElements.empty) {
			switch rootHardwareElements.get(0)  {
				Compartment : 	HardwareArchitectureLevelType.COMPARTMENT
				Box: 			HardwareArchitectureLevelType.BOX
				Board: 			HardwareArchitectureLevelType.BOARD
				Processor: 		HardwareArchitectureLevelType.PROCESSOR
				Core: 			HardwareArchitectureLevelType.CORE
			}
		}
	}
	
	@GenModel(documentation="Returns the bottom hardware level for this result")
	derived HardwareArchitectureLevelType bottomHardwareLevel get {
		HardwareArchitectureLevelType.CORE
	}
	
//	@GenModel(documentation="Contains a list of all io adapters")
//	contains IOAdapter[0..*]				ioAdapters
	
	@GenModel(documentation="Contains a list of all application groups")
	contains ApplicationGroup[0..*]			applicationGroups
	
	@GenModel(documentation="Contains a list of all applications")
	contains Application[0..*]				applications
	
	@GenModel(documentation="Contains a list of all networks")
	contains Network[0..*] 					networks

	@GenModel(documentation="Contains a list of all communication relations between applications")
	contains CommunicationRelation[0..*]	communications
	
	@GenModel(documentation="Contains the results of the evaluation for this result")
	contains Evaluation[0..1] 				evaluation
	
	op int compareTo(Result o) {
		val double diff = this ?. evaluation.totalScaledScore - o ?. evaluation.totalScaledScore;
		if (diff < 0.0)	return 1;
		if (diff > 0.0)	return -1;
		return 0;
	}
	
	@GenModel(documentation="Creates a list of all cores")
	op Core[] getAllCores() {
		val list = new BasicEList<Core> // FIXME: Implement me!
		return list
	}
	
	@GenModel(documentation="Creates a list of all processors")
	op Processor[] getAllProcessors() {
		val list = new BasicEList<Processor> // FIXME: Implement me!
		return list
	}
	
	@GenModel(documentation="Creates a list of all boards")
	op Board[] getAllBoards() {
		val list = new BasicEList<Board> // FIXME: Implement me!
		return list
	}
	
	@GenModel(documentation="Finds an application in the result model which represents a given Application in the input model")
	op Application findResultApplication(ch.hilbri.assist.model.Application modelApp) {
		for (resultApp : applications) 
			if (resultApp.referenceObject == modelApp) return resultApp
		return null	
	}
	
	@GenModel(documentation="Finds an applicationgroup in the result model which represents a given ApplicationGroup in the input model")
	op ApplicationGroup findResultApplicationGroup(ch.hilbri.assist.model.ApplicationGroup modelAppGroup) {
		for (resultAppGroup : applicationGroups) 
			if (resultAppGroup.referenceObject == modelAppGroup) return resultAppGroup
		return null	
	}
}


class HardwareElement {
	String name
	refers ch.hilbri.assist.model.HardwareElement referenceObject
	op HardwareArchitectureLevelType getHardwareLevel()
	
}

class Compartment extends HardwareElement {
	String manufacturer
	String powerSupply
	String side
	String zone
	contains Box[1..*] boxes opposite compartment
	op HardwareArchitectureLevelType getHardwareLevel() { HardwareArchitectureLevelType.COMPARTMENT }
}

class Box extends HardwareElement {
	String manufacturer
	container Compartment compartment opposite boxes
	contains Board[1..*] boards opposite box
	op HardwareArchitectureLevelType getHardwareLevel() { HardwareArchitectureLevelType.BOX }
}

class Board extends HardwareElement {
	String 						manufacturer
	String 						boardType
	String 						powerSupply
	DesignAssuranceLevelType 	assuranceLevel = "None"
	int 						ramCapacity
	double						ramUtilization
	int 						romCapacity
	double						romUtilization
	container Box 				box opposite boards
	contains Processor[1..*] 	processors opposite board
	contains IOAdapter[0..*] 	ioAdapters
	refers Network[0..*] 		networks opposite boards
	
	@GenModel(documentation="Is this processor used? Does it contain any mapped threads?")
	derived boolean 	notUsed	get { 
		var result = false
		for (p : processors) 
			result = result || p.notUsed
		return result 
	} 
	
	@GenModel(documentation="Creates a list of all applications being mapped to this board")
	op Application[] getAllApplications() {
		val list = new BasicEList<Application> // FIXME: Implement me!
		return list
	}
	
	op HardwareArchitectureLevelType getHardwareLevel() { HardwareArchitectureLevelType.BOARD }
}

class Processor extends HardwareElement {
	String manufacturer
	String processorType
	container Board board opposite processors
	contains Core[1..*] cores opposite processor
	
	@GenModel(documentation="Is this processor used? Does it contain any mapped threads?")
	derived boolean 	notUsed	get { 
		var result = false
		for (c : cores) 
			result = result || c.notUsed
		return result 
	} 
	
	op HardwareArchitectureLevelType getHardwareLevel() { HardwareArchitectureLevelType.PROCESSOR }
}

class Core extends HardwareElement {
	String 						architecture
	int 						capacity
	int							utilization
	derived double				relativeUtilization get { utilization as double  * 100.0 / capacity as double}
	container Processor 		processor opposite cores
	refers Thread[0..*] 		threads
	
	@GenModel(documentation="Is this core used? Does it contain any mapped threads?")
	derived boolean notUsed		get { threads.empty }
	
	@GenModel(documentation="How much absolute capacity of this core is left unused?")
	derived int remainingAbsoluteCapacity get { capacity - utilization	}
	
	@GenModel(documentation="How much relative capacity of this core is left unused?")
	derived double remainingRelativeCapacity get { remainingAbsoluteCapacity as double / capacity as double	}
	
	op HardwareArchitectureLevelType getHardwareLevel() { HardwareArchitectureLevelType.CORE }
}

class IOAdapter {
	String name
	int totalUnitCount
	IOAdapterType adapterType
	IOAdapterProtectionLevelType protectionLevel = "None"
	refers ch.hilbri.assist.model.IOAdapter referenceObject
}

class Network {
	String name
	int bandwidthCapacity
	derived boolean isBoardLocalNetwork get { boards.size <= 1 }
	refers Board[2..*] boards opposite networks
	refers ch.hilbri.assist.model.Network referenceObject
}

class ApplicationGroup {
	String name
	refers Application[0..*] applications
	refers ApplicationGroup[0..*] applicationGroups
	refers ch.hilbri.assist.model.ApplicationGroup referenceObject
}

class Application {
	String 									name
	int 									coreUtilization
	int 									ramUtilization
	int 									romUtilization
	DesignAssuranceLevelType 				criticalityLevel 					= "None"
	IOAdapterProtectionLevelType 			ioAdapterProtectionLevel 			= "None"
	int 									parallelThreads 					= "1"
	String 									developedBy
	contains IOAdapterRequirement[0..*] 	ioAdapterRequirements
	refers HardwareElement[0..*] 			restrictMappingToHardwareElements
	contains Thread[0..*] 					threads opposite application
	refers ch.hilbri.assist.model.Application referenceObject
}

class Thread {
	container Application 	application opposite threads
	derived String			name get { application.name + '_' + application.threads.indexOf(this) }
	refers ch.hilbri.assist.model.Thread referenceObject
}

class IOAdapterRequirement {	
	IOAdapterType 	adapterType
	int 			requiredUnits 		= "0"
	boolean 		isSharedAllowed 	= "false"
	boolean 		isExclusiveOnly 	= "false"
	refers ch.hilbri.assist.model.IOAdapterRequirement referenceObject
}

class CommunicationRelation{
	refers Application[1..*] applicationsOrGroups
	int bandwidthUtilization
	refers ch.hilbri.assist.model.CommunicationRelation referenceObject
}

class AbstractMetric  {
	String 			name
	int				weight
	boolean 		higherScoreIsBetter
	boolean 		builtIn = "true"
	op double 		computeAbsoluteScore(Result result) { 0 }
}

type MetricScoreMap wraps HashMap<AbstractMetric, Double>

class Evaluation {

	MetricScoreMap					absoluteScores
	MetricScoreMap					scaledScores
	
	derived double					totalScaledScore get { 
		if ((scaledScores == null) || (scaledScores.keySet.size == 0)) return 0.0
		else scaledScores.values.reduce[i1, i2 | i1 + i2]
	}
	contains AbstractMetric[0..*] 	metricsUsed
}
